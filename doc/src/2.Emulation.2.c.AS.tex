\subsubsection{Médiation des Appels Système}
%% pourquoi: read/write, comm reseau 

En regardant la Fig.\ref{AS_Communication} et les différents niveaux
d'abstractions, le moyen le plus simple pour attraper les actions de
l'application en gérant un minimum de choses est d'intercepter directement les
appels systèmes.  Ces derniers sont constitués de deux parties; la première,
l'entrée, initialise l'appel via les registres de l'application qui contiennent
les arguments de l'appel puis donne la main au noyau. La seconde, la sortie,
inscrit la valeur de retour de l'appel système dans le registre de retour de
l'application, les registres d'arguments contenant toujours les valeurs reçues à
l'entrée de l'appel système, et rend la main à l'application. \textit{Nous
  devons donc bloquer l'application à chaque interception d'une deux parties de
  l'appel système. Nous permettant ainsi de récupérer et modifier les
  informations permettant de maintenir l'environnement simulé avant de lui
  rendre la main, pour pouvoir entrer ou sortir de l'appel système.}

 Dans cette section, nous allons présenter les outils existants qui permettent
 de faire cela.
 
 \paragraph{L'appel système ptrace}\citep{AS:Interception, MARION:Interception}
 , dont la Fig.\ref{PTRACE_FONCTIONNEMENT} illustre le fonctionnement, permet de
 tracer tous les événement désirés d'un processus. Il peut également lire et
 écrire directement dans l'espace d'adressage de ce dernier, à n'importe quel
 moment ou lorsque un événement particulier se produit. De cette façon on peut
 contrôler l'exécution d'un processus. C'est un appel système dont chaque action
 à effectuer est passée sous forme de requêtes en paramètre de l'appel système.

Pour pouvoir contrôler un processus via \texttt{ptrace}, on va créer deux
processus parents via un \texttt{fork}(); un processus appelé ``processus
espionné'' qui exécutera l'application et qu'on souhaite contrôler, et un autre
qui contrôlera le processus espionné, appelé ``processus espion''. Le processus
espionné indiquera au processus espion qu'il souhaite être contrôlé via un appel
système \texttt{ptrace} et une requête \texttt{PTRACE\_TRACEME} puis il
exécutera l'application via un \texttt{exec}(). À la réception de cet appel, le
processus espion notifiera son attachement au processus espionné via un autre
appel à \texttt{ptrace} et une requête \texttt{PTRACE\_ATTACH}. Il indiquera
également sur quelles actions du processus espionné il veut être notifié (chaque
instruction, signal, sémaphore...), définissant ainsi les actions bloquantes
pour le processus espionné. Dans notre cas, ce seront les appels systèmes que
l'on considérera comme points d'arrêts (requête
\texttt{PTRACE\_SYSCALL)}. Ainsi, le processus espion sera donc appelé deux
fois: à l'entrée et à la sortie de l'appel système.

Quand un des processus de l'application voudra faire un appel système, il sera
bloqué avant de l'exécuter et le processus espion qui lui est associé sera
notifié via un appel système \texttt{ptrace}. Ce dernier fera alors les
modifications nécessaires dans les registres du processus espionné pour
conserver la virtualisation de l'environnement. Pour cela il pourra utiliser les
requêtes \texttt{PEEK\_DATA} et \texttt{POKE\_DATA} passées en argument de
l'appel système {\color{red} (à éclaircir)\textbf{ou modifier directement le
    contenu du /proc/id/mem}}. Puis, il rendra la main au processus espionné
pour que l'appel système puisse avoir lieu.%% Au retour de
%% l'appel système le processus espionné sera de nouveau stoppé et un \texttt{ptrace} sera
%% envoyé au processus espion qui remodifiera les informations nécessaires. Puis il
%% rendra la main au processus espionné bloqué qui sortira de son appel système
%% avec un résultat exécuté sur la machine hôte et un temps d'exécution et une
%% horloge fournie par le simulateur.
 Le même fonctionnement est utilisé pour le retour de l'appel
 système. \textit{Le processus espion change simplement le temps d'exécution de
   l'appel système et l'horloge de l'application en utilisant ceux calculés par
   le simulateur.}  Quand un processus espion a fini un suivi, il peut envoyer
 deux types de requêtes au processus espionné: \texttt{PTRACE\_KILL} qui termine
 le processus espionné ou \texttt{PTRACE\_DETACH} qui le laisse continuer son
 exécution.

\begin{figure}
   \centering
   \includegraphics[scale=0.5]{Pictures/png/ptrace_fonctionnement}
   \caption{Attachement d'un processus et contrôle via un espion}
   \label{PTRACE_FONCTIONNEMENT}
 \end{figure}

Néanmoins, pour contrôler un processus, \texttt{ptrace} fait de nombreux
changements de contexte pour pouvoir intercepter et gérer les événements, or
cela coûte plusieurs centaines de cycle CPU. \textit{De plus, il supporte mal
  les processus utilisant du multithreading, et ne fait pas parti de la norme
  POSIX. Ainsi il peut ne pas être disponible sur certaines architectures et son
  exécution peut varier d'une machine à une autre.}

\paragraph{Uprobes}\citep{AS:Interception, MARION:Interception}
%% Non module noyau

%% pour \textit{user-space probes}, quant à lui permet d'insérer dynamiquement des
%% points d'arrêts à n'importe quel endroit dans le code d'une application, dans
%% notre cas les appels systèmes. Pour chaque point d'arrêt, l’utilisateur fournit
%% un handler particulier à exécuter avant ou après l’instruction marquée. Uprobes
%% étant un outil s'exécutant dans le noyau, les handlers doivent être placé dans
%% un module. Pour chaque point d'arrêt géré par Uprobes, le module noyau contient
%% le handler à exécuter, ainsi que le processus et l'adresse virtuelle du point
%% d'arrêt. Lorsqu'un point d'arrêt est atteint Uprobes prend la main et exécute le
%% bon handler. Pour savoir qu'un point d'arrêt a été touché, Uprobes utilise
%% Utrace, équivalent de ptrace en mode noyau. Ce dernier permet d'éviter les
%% nombreux changements de contexte et est capable de gérer le
%% multithreading. Utrace peut également être utilisé dans le module gérant un
%% point d'arrêt pour récupérer des informations sur l'application et les données
%% qu'elle utilise.

%% Les deux avantages de cette solution sont qu'elle est rapide et qu'elle a accès
%% à toutes les ressources sans aucune restriction. Mais ce dernier point
%% représente aussi son plus gros défaut de par sa dangerosité. De plus, dans notre
%% cas il ne semble pas judicieux de faire de la programmation noyau via un
%% module dont l'utilisateur devra également gérer le bon chargement.

pour \textit{user-space probes}, quant à lui est une API noyau permettant
d'insérer dynamiquement des points d'arrêts à n'importe quel endroit dans le
code d'une application, dans notre cas les appels systèmes, et à n'importe quel
moment de son exécution.

Il existe deux versions de Uprobes la première est basée sur les ``trace
hook\footnote{\url{http://fr.wikipedia.org/wiki/Hook\_\%28informatique\%29}}''\textbf{{\color{red}citation}}. Cette
solution ne sera pas développée ici car elle est très peu utilisée
\textbf{{\color{red} à vérifier}}.

La seconde, la plus connue, se base sur Utrace, équivalent de \texttt{ptrace} en
mode noyau. Ce dernier permet d'éviter les nombreux changements de contexte, qui
dégradent les performances, et est capable de gérer le multithreading. Dans
cette version, l'utilisateur fournit pour chaque point d'arrêt un handler
particulier à exécuter avant ou après l’instruction marquée. Uprobes étant un
outil s'exécutant dans le noyau, les handlers doivent être placés dans un module
noyau. Ce dernier contient pour chaque point d'arrêt géré par Uprobes le handler
à exécuter, ainsi que le pid du processus concerné et l'adresse virtuelle du
point d'arrêt. Pour gérer un point d'arrêt Uprobes utilise trois structures de
données \textit{i)} \texttt{uprobe\_process} (une par processus controlé),
\textit{ii)} \texttt{uprobe\_task} (autant que le processus contrôlé a de
thread), \textit{iii)} \texttt{uprobe\_kimg} (une pour chaque point d'arrêt
affectant un procesus). Chaque structure \texttt{uprobe\_task} et
\texttt{uprobe\_kimg} sont propres à une structure \texttt{uprobe\_process}. La
fonction \texttt{init}() du module va poser les points d'arrêt et la fonction
\texttt{exit}() les enlevera. Pour cela on utilise respectivement la fonction
\texttt{register\_uprobe} et \texttt{unregister\_uprobe}. Ces deux fonctions ont
pour argument le pid du processus à contrôler, l'adresse virtuelle du point
d'arrêt dans le code et le handler à exécuter quand le point d'arrêt est
atteint. La fonction \texttt{register\_uprobes} va trouver le processus passé en
paramètres en parcourant la liste des structures \texttt{uprobes\_process} ou la
crééra si cette dernière n'existe pas. Ensuite, elle crée la structure
\texttt{uprobe\_kimg}, puis fait appel à Utrace pour bloquer l'application, le
temps de placer le point d'arrêt dans le code de celle-ci. Pour cela, on va
placer avant l'instruction sondée un appel au module contenant le handler à
invoquer, puis on rend la main à l'application en utilisant de nouveau
Utrace. \texttt{unregister\_uprobe} fait de même mais supprime la structure
\texttt{uprobe\_kimg} passée en paramètre au lieu de l'ajouter. De plus, s'il
s'agit de la dernière structure de ce type pour un processus contrôlé, il
supprimera alors la structure \texttt{uprobe\_process} et toutes les
\texttt{uprobe\_task} associées.

Lorsqu'un point d'arrêt est atteint Uprobes prend la main et exécute le bon
handler. Pour savoir qu'un point d'arrêt a été touché, Uprobes utilise de
nouveau Utrace, ce dernier envoyant un signal à Uprobes à chaque fois que le
processus qu'il contrôle atteint un point d'arrêt.

Utrace envoie également un signal à Uprobes quand un des processus contrôlé fait
un appel à \texttt{fork}()/\texttt{clone}(), \texttt{exec}(), \texttt{exit}()
pour que ce dernier créé ou supprime les structures uprobe\_process
concernées. Utrace peut également être utilisé dans le handler gérant un point
d'arrêt pour récupérer des informations sur l'application et les données qu'elle
utilise. De plus, un handler peut également ajouter ou enlever des points
d'arrêts.

Les deux avantages de cette solution sont qu'elle est rapide et qu'elle a accès
à toutes les ressources sans aucune restriction. Mais ce dernier point
représente aussi son plus gros défaut de par sa dangerosité. De plus, dans notre
cas il ne semble pas judicieux de faire de la programmation noyau via un module
dont l'utilisateur devra également gérer le bon chargement.

\paragraph{Seccomp/BPF:}
%% Read only
\label{paragraph:seccomp/bpf}

Seccomp \citep{seccompbpf} est un appel système qui permet d'isoler un processus
en lui donnant le droit d'appeler et d'exécuter qu'un certain nombre d'appels
systèmes: \textit{read}, \textit{write}, \textit{exit} et \textit{sigreturn}. Si
le processus fait un autre appel système, il sera arrêté avec un signal
\texttt{SIGKILL}. Comme cela est assez contraignant, le nombre d'applications
que l'on peut utiliser avec seccomp est donc très limité. Pour plus de
flexibilité, on peut utiliser une extension de cet appel système appelée
seccomp/BPF, pour \textit{seccomp BSD Packet Filter}, permettant de définir dans
un programme BPF \citep{BPF_mccanne1993bsd} les appels systèmes autorisés à
s'exécuter, en plus de ceux cités précédemment. Cette dernière fonctionne sur le
même principe que le filtrage de paquet réseau où on établit une suite de
règles. Pour pouvoir s'exécuter, un appel système doit pouvoir passer à travers
toutes les règles. Dans le cas où les appels systèmes \texttt{fork}() ou
\texttt{clone}() peuvent s'exécuter, l'arborescence de filtres est transmise aux
enfants, de même que pour les processus faisant des appels \texttt{execve}()
quand ils sont autorisés. Les règles des filtres BPF portent sur le type de
l'appel système et/ou ses arguments. Ainsi, à chaque entrée ou sortie d'un appel
système, ne faisant pas partie des quatre autorisés par seccomp, l'extension
utilisant BPF est appelée. Elle reçoit en entrée le numéro de l'appel système,
ses arguments et le pointeur de l'instruction concernée. En fonction des règles,
elle laisse l'appel système s'exécuter ou pas.  De plus, seccomp/BPF possède une
option qui lui permet de générer un appel système \texttt{ptrace}(). Cela permet
au processus espion, s'il existe, de ne plus attendre sur chaque appel système
du processus espionné, mais uniquement sur les appels systèmes qu'il souhaite
intercepter.

Néanmoins, l'appel système seccomp et son extension seccomp/BPF ne sont
disponibles que si le noyau est configuré avec l'option \texttt{CONFIG\_SECCOMP}
pour la première et \texttt{CONFIG\_SECCOMP\_FILTER} pour la deuxième. Pour
pouvoir créer des filtres, il faut également avoir des droits particuliers,
notamment l'exécution de certaines commandes root. Ainsi, l'utilisation de cet
appel système et de son extension demande une certaine configuration noyau et
des privilèges pour les utilisateurs, ce qui n'est pas très conseillé.

De plus, si on l'utilise sans l'option d'appel à \texttt{ptrace} on ne peut que
lire le contenu de l'appel système et pas le modifier. On ne peut donc pas faire
de médiation avec cet outil sans faire appel à \texttt{ptrace}. Néanmoins,
l'utilisation de seccomp/BPF avec \texttt{ptrace} permet de réduire
signifiquativement le nombre d'événement sur lequel attendra le processus
espion.
\newline
Malgré ses défauts, l'appel système \texttt{ptrace} semble être le meilleur
outil pour faire ce type d'interception. Néanmoins, il a été montré dans un
précédent stage \citep{MARION:Interception} qu'il est inefficace voire inutile
en ce qui concerne tous les appels systèmes temporels qu'une application
souhaiterait exécuter (\texttt{time}(), \texttt{clock\_gettime}(),
\texttt{gettimeofday}()) car le noyau ne les exécute pas. Cela est du à
l'existence de la bibliothèque \textit{Virtual Dynamic Shared Object}
(VDSO). Cette dernière vise à minimiser les coûts dûs aux deux changements de
contexte effectués lors de l'exécution d'un appel système. VDSO va retrouver
l'heure \textit{{\color{red}dans le contexte noyau}} lisible par tous les
processus sans changer de mode. Il est possible de désactiver cette bibliothèque
lors du boot mais cela réduit les performances (plus de changements de contexte)
et oblige l'utilisateur à modifier les paramètres de son noyau. On peut donc
dire que cette solution d'interception n'est donc pas complète.

%%avec \textbf{ptrace} ne sont pas possibles, d'où l'alliance
%%   avec LD\_PRELOAD} Par exemple lors d'un gettimeofday l'appel système n'est pas
%% lancé on répond directement au niveau de la bibliothèque ainsi on n'arrive même
%% pas au niveau de l'appel système, donc ptrace ne fait rien.  Problème
%% portabilité {\color{red} \textbf{gérer cette transition}}
