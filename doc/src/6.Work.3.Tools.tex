\subsection{Améliorations apportées à Simterpose}

Au début de ce stage, Simterpose ne pouvait être exécuté que sur des architectures 64bits. Considérant qu'il est important qu'un tel programme puisse s'exécuter sur tous les types d'architecture, nous avons voulu qu'il puisse s'exécuter sur des machines 32bits. Il existe plusieurs différences entre les architectures 32bits et 64bits, dont certaines sont susceptibles d'affecter Simterpose auxquelles nous allons nous intéresser. La première différence est que les registres ne portent pas les mêmes noms selon le type d'architecture qu'on utilise (cf. tableau \ref{register}). Or, lorsqu'on intercepte des appels systèmes il faut pouvoir récupérer les valeurs contenues dans les registres à l'entrée de l'appel système puis écrire dans ces mêmes registres à la sortie. Afin d'exécuter Simterpose sur ces deux architectures il faut donc avoir une version du code pour chacune. La seconde différence est que certaines \texttt{macro} et appels systèmes n'existent pas sur des architectures 64bits et inversement. C'est la cas de deux appels systèmes particulièrement importants car ils touchent au réseau: \texttt{send} et \texttt{recv}. Ces deux appels ne sont définis que pour des architectures 32bits, sur des architectures 64bits quand on les utilise ils sont remplacés par les appels sytèmes \texttt{sendto} et \texttt{recvfrom}.

\begin{table}[H]
\centering
\begin{tabular}{lcccccccc}
\cline{2-9}
\multicolumn{1}{l|}{}              & \multicolumn{1}{c|}{{\bf \begin{tabular}[c]{@{}c@{}}Numéro de\\ l'appel système\end{tabular}}} & \multicolumn{1}{c|}{{\bf \begin{tabular}[c]{@{}c@{}}Valeur \\ de retour\end{tabular}}} & \multicolumn{1}{c|}{{\bf arg0}} & \multicolumn{1}{c|}{{\bf arg1}} & \multicolumn{1}{c|}{{\bf arg2}} & \multicolumn{1}{c|}{{\bf arg3}} & \multicolumn{1}{c|}{{\bf arg4}} & \multicolumn{1}{c|}{{\bf arg5}} \\ \hline
\multicolumn{1}{|c|}{{\it 32bits}} & \multicolumn{1}{c|}{orig\_eax}                                                                 & \multicolumn{1}{c|}{eax}                                                               & \multicolumn{1}{c|}{edi}        & \multicolumn{1}{c|}{esi}        & \multicolumn{1}{c|}{edx}        & \multicolumn{1}{c|}{r10d}       & \multicolumn{1}{c|}{r8d}        & \multicolumn{1}{c|}{r9d}        \\ \hline
\multicolumn{1}{|c|}{{\it 64bits}} & \multicolumn{1}{c|}{orig\_rax}                                                                 & \multicolumn{1}{c|}{rax}                                                               & \multicolumn{1}{c|}{rdi}        & \multicolumn{1}{c|}{rsi}        & \multicolumn{1}{c|}{rdx}        & \multicolumn{1}{c|}{r10}        & \multicolumn{1}{c|}{r8}         & \multicolumn{1}{c|}{r9}         \\ \hline
                                   & \multicolumn{1}{l}{}                                                                           & \multicolumn{1}{l}{}                                                                   & \multicolumn{1}{l}{}            & \multicolumn{1}{l}{}            & \multicolumn{1}{l}{}            & \multicolumn{1}{l}{}            & \multicolumn{1}{l}{}            & \multicolumn{1}{l}{}           
\end{tabular}
\caption{Nom des différents registres d'un appel système selon le type d'architecture}
\label{register}
\end{table}

La seconde amélioration est une mise à niveau de Simterpose pour qu'il puisse utiliser les dernières versions de SimGrid. Pour cela, il a fallu remplacer d'anciennes fonctions et variables encore utilisées dans le code de Simterpose par les nouvelles utilisées dans SimGrid. Cela a également permi de mettre à jour un problème dans SimGrid. Au début de mon stage, Simterpose utilisait une version de SimGrid datant de 2011, maintenant il utilise la version f42adf1 de git sortie le 16 Août 2015.

\vspace{0.5cm}
Troisièmement, nous souhaitons pouvoir utiliser un autre débogueur en plus de \texttt{gdb}. Nous avons choisi Valgrind pour les nombreux modules qu'il fourni, notamment \texttt{memcheck} qui est pour nous le plus intéressant. Ce dernier traque les fuites mémoires et résume en fin d'exécution tout ce qui a été réservé, libéré et perdu en mémoire. Pour permettre son utilisation avec Simterpose nous avons dû implémenter l'appel système \texttt{fcntl}. Valgrind utilise cet appel système pour accéder à l'exécution de Simterpose et ainsi chercher les fuites mémoires. L'implémentation d'un handler pour cet appel n'était pas prévu à la création de Simterpose puisque nous voulons juste intercepter les appels systèmes réseaux, temporels et gérer les processus et leurs threads pour maintenir notre environnement virtuel et aucun débogueur autre que \texttt{gdb} ne souhaitait être utilisé à ce moment-là.

 \vspace{0.5cm}
Pour finir, le but de Simterpose étant d'exécuter des applications distribuées large échelle, nous souhaitions initialement pouvoir exécuter des applications de Torrent. De fait, lorsqu'on exécute des applications de ce type, le système de fichier de la machine hôte est en permanence utilisé. Simterpose dispose en parallèle de son propre système de fihier. Pour chaque socket ou fichier il dispose d'un descripteur avec des compteurs de références, les processus qui les référencent, les verrous qui peuvent être posés... Nous devons donc nous aussi maintenir à jour notre système de fichier dans le cas où nous lancerions ce genre d'applications. Ainsi, nous devons maintenant intercepter les appels systèmes touchant aux fichiers en plus de ceux affectant le réseau en utilisant toujours \texttt{ptrace}. Lorsqu'on les intercepte il faut récupérer les modifications qui seront effectués sur le système de fichier réel une fois qu'on aura laissé passer l'appel système et les appliquer au système de fichier propre à Simterpose. Actuellement, Simterpose gére les appels systèmes: \texttt{open},  \texttt{close}, \texttt{creat}, \texttt{dup}, \texttt{dup2}, \texttt{poll}, \texttt{fcntl}, \texttt{lseek}, \texttt{read}, \texttt{write}. Il est possible que Simterpose soit amener à gerer d'autre appels systèmes de ce type à l'avenir.
