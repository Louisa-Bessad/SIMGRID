%% Cette solution d'interception est implémentée dans \textbf{Simterpose}{\color{red}mettre citation}.

%% Pour ce qui est du type d'émulation utilisé, c'est l'émulation par interception qui a été choisi. Le but final du projet étant de pouvoir évaluer n'importe quelle application distribuée sur n'importe quel type d'architecture, on pourrait se retrouver à devoir émuler des machines plus puissantes que l'hôte, ce que l'émulation par dégradation ne permet pas. Pour faire cette émulation on va utiliser SIMGRID comme simulateur et Simterpose comme API de ce simulateur. Simterpose jouera donc le rôle d'émulateur et nous permettra d'utiliser SIMGRID avec des applications réelles tout en leur faisant croire qu'elles s'exécutent sur des machines distinctes. 

\section{Symbôles sur lesquels faire de la médiation}
\label{section:simterpose}
%% Simterpose est l'API qui va nous permettre d'intercepter les communications de
%% l'application avec la machine sur laquelle elle s'exécute. Sans cela,
%% l'application se rendrait compte que l'environnement réel ne correspond pas
%% celui dans lequel elle pense s'exécuter.

\subsection{Organisation générale}
%schéma tableau

\subsection{Les communications réseaux}
 %-> syscall -> ptrace (full mediation, address translation)
%% Lorsque ptrace est appelé en entrée ou sortie d'appel système, les modifications
%% à apporter ne sont pas forcément les mêmes selon qu'il s'agit d'une action
%% nécessitant l'utilisation du réseau ou non. Dans le cas d'un simple calcul ce
%% qu'il faut maintenir pour l'application, c'est une vision du temps correspondant
%% à celle qui s'écoulerait si elle était vraiment sur la machine simulée. Ainsi en
%% entrée d'appel système on n'a pas besoin de modifier quoique ce soit, par contre
%% au retour il faut modifier le temps d'exécution du calcul en le remplaçant par
%% celui calculé par le simulateur. Dans le cas d'une communication réseau il faut
%% gérer la transition entre réseau local et réseau simulé. En effet l'application
%% possède une adresse IP et des numéros de ports ``virtuels'' qui ne correspondent
%% pas forcément à ceux attribués dans le réseau local. De plus on ne peut pas se
%% baser uniquement sur les numéros de \textit{file descriptor} associé à une
%% socket pour identifier deux entités qui communiquent entre elles.En effet ces
%% \textit{file descriptor} sont uniques pour chaque socket d'un processus, mais
%% plusieurs processus peuvent avoir un même numéro de \textit{file descriptor}
%% pour des sockets de communicatiosn différentes puisque chacune à son propre
%% espace mémoire. Pour pallier à ce probème on va utiliser en plus du numéro de
%% socket, les adresses IP et les ports locaux et distants des deux entités qui
%% souhaitent communiquer comme moyen d'identification. Pour gérer toutes ces
%% modifications deux solutions ont été proposées lors d'un précédent stage \cite{interception:GUILLAUME:interception_syscall}: la
%% ``médiation par traduction d'adresse'' et la ``full mediation''.

%% {\color{red}schéma}
%% \paragraph{Traduction d'adresse}
%%  Avec ce type de médiation on considère que le noyau gère des
%%  communications. Ainsi en entrée et sortie d'appel système Simterpose va juste
%%  s'occuper de la transition entre réseau ``virtuel'' et réseau local. Pour cela
%%  Simterpose gère un tableau de correspondance, dans lequel pour chaque
%%  application on a un couple (adresse IP et des ports ``virtuels'', adresse IP et
%%  ports ``réel'' sur le réseau).  De fait en entrée de l'appel système,
%%  Simterpose devra remplacer l'adresse et les ports ``virtuels'' de l'application
%%  par l'adresse et les ports réels sur le réseau local, ainsi l'appel système se
%%  fera avec une source qui existe réellement sur le réseau. Au retour de l'appel
%%  système il faudra remodifier les paramètres en remettant l'adresse et les ports
%%  ``virtuels'' pour que l'application pense toujours être dans son environnement
%%  simulé.  La limite de cette approche est lié au nombre de port disponibles sur
%%  l'hôte. 

%% \paragraph{Full mediation} 
%% Dans ce cas le noyau ne va plus gérer des communications car nous allons
%% empêcher l'application d'établir des connexions avec une autre application via
%% des sockets. Il n'y aura ni socket ni communication. Quand l'application voudra
%% faire un appel système de type communication vers une autre applciation, le
%% processus espion de Simterpose qui sera notifié via ptrace neutralisera l'appel
%% système. Ensuite ce processus en utilisant ptrace récupérera en lisant dans la
%% mémoire du processus espionné les ifnormations à envoyer ou récupérer et ira
%% directement lire ou écrire ces informations dans la mémoire du
%% destinataire. Ainsi on n'a pas besoin de gérer de tableau de correspondance
%% d'adresse et de ports et les applications peuvent conserver les adresses
%% simulées qu'elles considèrent comme réelles.  Même si la ``full mediation''
%% permet d'éviter les communications réseaux et de conserver des tables de
%% correspondances, dans le cas d'applications qui communiquent énormément et
%% utilisent de grosses données elle s'avère moins efficace. En effet les appels à
%% mémoires sont bien plus couteux que les communications réseaux.

\subsection{Les thread}
 %% syscall clone + libcalls

\subsection{Le temps}
 %% -> syscall (- system wide), VDSO-linker (cross process ou VDSO)

\subsection{DNS}
%% libcalls (ne rien rater), config fake (system wide), intercept 53 ( plus dur que nécessaire, port dns autre ou pas)
