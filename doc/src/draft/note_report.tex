-------------------------------------------------------------
UPROBES
utrace monitor individuellement les thread Linux
- une version sans utrace (roland's tracehooks) et unee avec utrace pour gérer les points d'arrêt 

kernel API (IBM) patch noyau = uprobes (LWN)
crée et gère probepoints ds appli utilisateur

uprobes c'est:
- fonction init du module qui pose les points etfonction clean les enlève
%% %% - points d'arrêt dans noyau via kprobes
- ~~~~ handler peut dynamiquement ajouter, enlever probes
%% - pas limitation du nb process et thread, points d'arrêt mis quand on veut ds exec prog, et plusieurs module different peuvent taper les meme points de meme proc
%% - chaque processus possède sa copie de la page de point d'arret maj à chaque
%% modification des pints
%% -handler x dans le contexte du processus donc pas changement contexte pour aller dans le parent co ptrace
- struct de donnees pr chaque tache uprobe_task et pour chaque processus uprobe_process etpour chaque opoin d'arret uprobe_kimg (Kernel IMaGe) 1 et 3 contenu dans 2
%% %- probe point commun à tous les thread puisque partage zone code
- coeur = uprobe_register(pid, offset de placement du probe depuis le début du fic, struct contenant handler et filtre qui est optionnel permet de dire que faire a chaque touche differente du meme point)
- register_uprobe() et unregister_uprobe() chacun prend un pointeur sur un point d'arrê décrit dans le module noyau uprobe object ( pid @V handler)
- registr trouve le proc specifie en parcourant uprobe_process ou le crée sinon ainsi que la tâche. Puis crée le point d'arrêt et appel uutrace pour placer le point d'arrêt  et bloque le proc et tous ses thread pendant ce temps puis retour
- de meme pr unregister, par contre si dernier kimg supprime toutes les tructures uprobe_process et uprobe_tasks
- qd point arret save, uprobes copie l'instruction sondée, stop appli, remplace 1ers o de l'inst par le module ocntenant le handler à invoquer puis rend la main a l'appli

%% - rapide permet eviter  la multiplication des changements de contexte qui nuit aux perf


-------------------------------------------------------------
DISTEM
C quoi:
- logiciel pour construire des environnements de test distribués virtuels grâvce ens d'outils de Linux (LXC, CPU frequence et traffic ctrl)
- a partir d'un ensemble de noeuds homogènes on peut émuler une plateforme de noeud hétérogènes (nb et perf de coeurs de CPU connecré à un réseau virtuel
- solution de virtualisation légère utilisée = LXC (LinuX Container) pour permettre le passage à l'echelle (40000 noeuds virtuels)
- différentes interfaces selon les besoins des utilisateurs et e lengage de prog qu'ils veulent utiliser pour leur expériences (Script shell, ruby programs), user-griendly, logiciel libre.

Archi:
- simple, combine plusieurs outils libres et technologies efficaces dans leur domaine pour atteindre son objectif
- config automatique des tables de routage en fonction de la topologie réseau fournie

émulation de l'hétérogénéité:
- inversement possible
- changement à la volée des paramètres du réseau et de la vitesse du processeur (émulation de ressources CPU Distem est l'unique logiciel à utiliser cet outil)
- les coeurs physique de la machine peuvent  être alloué à un VN particulier et la vitesse de chaque coeur peut etre controllé pour être plus faible que la vitesse normal
=> ces 2 points permettent d'approcher à maximum de la réalité.

Comment:
- 1 specifier un res virtuel avec ltaence et bp ctrl sur chaque lien en in et out
- 2 emuler cap CPU degradees
- 3 pls Vnodes sur un PN
- Pnodes = noeuds physique non virtualisé pour la base de son infrastructure. Chaque pnode peut contenir plusieurs Vnodes. Les Vnodes sont séparé et n'ont pas conscience de la présence des autres Vnodes sur le Pnodes
- tous les Vnodes sont connectés sur un réseau Ethernet virtualisé
- chaque Pnodes possède son démon Distem qui controle les vnodres qu'il héberge. Le ctrl des liaisons et autres ressources sont pour Vnodes.
- un des Pnodes est le coordinator il est responsable du controle de l'infrastructure dans sa globalité en comuniquand ave les autres Pnodes.
- Vnode = LXC (conteneur possède un espace @ speare pour les ressources sytèmes: taches interfaces res, mémoire, DD..., mais partage version du noyau et le processuer => pb pour l'heterogeneite des perfs cpu des VM => utilisation de Linux Control Groups pour pouvoir assigner des coeurs à des conteurs. pour ctrl la vitesse des coeur assigné on utilise CPU-Hogs \textbf{citation et explciation}
- chaque vnode peut avoir pls interface res virtuelles. toutes les veth interfaces sont regroupées avec le reseau physique pr que chacun puisse accéder au réseau => partage du reseau Ethernet entre les differents res IP si aps séparés => pb ARP poisoning => modif taille et duree tables arp dans le noyau mais aps scalable => utilisation de VXLAN pour ajouter une couche d'abstraction dans le res quand on sort du Pnodes on route en direction du Pnodes contenant le Vnode destinataire et pas l'à du dest direct c arrive dans le Pnode que la couche VXLAN renverra au bon Vnode
- BP controlé par algo TBF, latence par netem file en entrée et en sortie indépendant
gère injection de faute sur res et sur les noeud

ccl:
res emule et infra detailles et realistes, simple et robuste mais limité à la reduction de perf pas emulation de ammchines plus rapides.


-------------------------------------------------------------
CWRAP outil d'émulation par interception
- cwrap's mission is to enable developers to test complex network-based and privileged software stacks on UNIX machines with limited network access and without root privileges by providing preloadable libraries to wrap standard libc functions.
- pour tester des appli réseaux (2005 tester proto dev par SAMBA) NSS modules
- pour lancer pls instances C/S sur la même machine et simuler configurations res complexe localement et router sur reseau local
- Daemons often require privilege separation and local user and group accounts, separate from the hosting system. The cwrap project does not require virtualization or root credentials and can be used on different operating systems.
- projet libre                  

- 4 bibliothèques principales
- socket\_wrapper (tous les appels => communiquer là-dessus pr router sur)
includes its version of most of the standard API used to communicate over sockets that routes the communication over local sockets.
redirige ttes les comm pr arriver sur des sockets unix
You are also able to simulate binding to privileged ports below port 1024, which normally requires root privileges.
en émulant le réseau on peut aussi communiquer sur les ports <1024
capture reseaux
-nss\_wrapper pour les projets où le demon doit pouvoir gérer des utilisateurs
il change le file passwd et group utiliser pendant la phase de test par le logiciel
pour tester des appli reseaux qui font de la gestion d'utilisateur ainsi que fichier de resolution de nom pour les adresses utilsiées avec les socket file host
- uid\_wrapper pour faire croire aux applications (peremt de simuler des droits utilisateur) qu'elles s'exécutent en root:
intercepte touts les appels de type setuid & getuid et réécrit le mapping entre les idfonctionneront meme pour user normal 
- ressolv\_wrapper
Redirects name queries to the nameservers specified in your resolv.conf
Can fake DNS queries using a simple formatted DNS hosts file.


-------------------------------------------------------------
DETER:
website:
- DETER projet de recherche et utilisateur DeterLab, banc de tests avancée emeule la complexité du monde réel pour tester les solutions de cybersécurié (pour protéger de cyber attaques et des failles reseau)
- DETER = projet de recherche + outil pour mener des tests de cybersecu
- The gap between threat and defense continues to widen
- mission: is to readily enable the research community to conduct advanced research in cyber security through use of DeterLab's innovative methods and advanced tools -- that allow for repeatable, scalable and scientifically verifiable experimentation -- for homeland security and critical infrastructure protection
- accelerer le dev solution de cybersecu efficace
- utilise DETERLab (plateforme d'experimentation pour les nouvelles tech) open, outils
DeterLab (cyber DEfense Technology Experimental Research Laboratory) is a state-of-the-art scientific computing facility for cyber-security researchers engaged in research, development, discovery, experimentation, and testing of innovative cyber-security technology. DeterLab is a shared testbed providing a platform for research in cyber security and serving a broad user community, including academia, industry, and government. To date, DeterLab-based projects have included behavior analysis and defensive technologies including DDoS attacks, worm and botnet attacks, encryption, pattern detection, and intrusion-tolerant storage protocols.
Innovations that work well in a predictable, controlled environment often turn out to be much less effective, reliable or manageable in a critical government or enterprise IT environment. Without realistic, large-scale resources and research environments, results are unpredictable. As a world-class facility used and shared by cyber security researchers from hundreds of institutions worldwide, our stress is on rigorous, repeatable testing in a realistic, large-scale test environment. We enable researchers to observe and interact with real malicious software, operating in realistic network environments at scales found in the real world. These experiments in turn lead to cyber-defense innovations and systems that are inherently more robust.
capable de partage des ressources entre différents test concurrents + outil et interface et datasets pour test secu
DeterLab base sur Emulab, etend le code pour permettre des tests de gde echelle et dont la complexite est representative des reseaux d'ojd et specialisee dans le domaine cyber
DETERLab =  Containers, for multi-resolution virtualization of experiment resources + DASH, for predictive modeling of human behavior supporting definition of mental models, reactive goal-driven behavior, and combinations of deliberative/instinctive behaviors + Federation and its ABAC authorization library, for connection of heterogeneous resources from different owners with varying usage and access policies + Multi-party experiments technology that provides controlled but co-joined experiments, creating different views of the experiment environment for multiple experimenters or groups of experimenters within one unified experiment + MAGI, for orchestrating networking experiments providing deterministic control over the various components in an experiment.
Multi-resolution virtualization of expreriment resources + federation to connect hetero resources from diff owners with varying usage and access policies + multi-party experiments (tech that provides controlled but co-joined experiments, creating different views within one unified experiment) + experiment orchestration (providing deterministic control over the various components in an experiment) + predictive + risky experiment management to allow controlled expe interaction with the real internet

Today, DeterLab is one of the largest facilities devoted to providing experimental resources and scientific expertise for the development, experimentation, and testing of innovative cyber-defense technology
- Experiments =  Observation of cyber-attack and cyber-defense technologies + Test-driven development of innovative cyber-defenses + Scientific test and measurement of the effectiveness of cyber-security innovations + Experimentation with multiple approaches to using a cyber-defense technology + Scientific assessment of hypotheses about cyber-attack and cyber-defense technology in action.
- new fields     ur range of cyber-security scientific work now covers several areas that include not only core cyber-security areas – such as DDoS defense, intrusion detection, and network defense for critical infrastructure control systems – but also new or cross-disciplinary research areas such as control-plane network security, provenance of network trace datasets, anonymity network robustness, and routing security and multicast security for smart power grids.
- DETER allows for cybersecurity researchers from around the globe to run their cyber experiments – test, evaluate response, and discover ‘best solutions’ – in a self-contained virtual Internet lab that is representative of the complexity and scale of the actual Internet.

plaquette
-DETER = recherche de methodes experimentales pour innovations dans recherche cybersecu (2003) + dev DeterLab (2004) + education cybersecu avec exo dispos
- virtual Lab free + auth control acces pour user + plateforme de test pr creer hote virtuel et reseau du Lab's hard reel + tools pr deisgn  virtual test network + automatisaiton tool pr test repeatable et proc exeprimentales + federationi avec autre tests lab pr augmenter la taille

2007
- supports experimentation on next-generation cyber security technologies, and
uses the Emulab cluster testbed software to control and manage a pool of PCs
- DETER testbeds[1] are a class of Emulab- based[2] testbed that provide a
secure experimental environment through configuration and management.  The DETER
project[3] at ISI runs a DETER testbed with segments located at USC/ISI and the
University of California at Berkeley consisting of more than 250 nodes.


-------------------------------------------------------------
RR
la plupart de l'exécution d'une appli est deterministe
rr sv les parties non deterministes (singaux, adresse des buffers et variables)
entree non deterministe = mem partagee en multi tache, mais rr ne sv pas des parallèles executions pour cout d'efficacite => emule machine monocoeur
utilisé au depart pour debug firefox
les appli sont non deterministes execution tjs diff et bug peut arriver apres x execution c difficile de debug de maniere traditionnelle => temps a debugger de meme pr les bug transitoire (pas reproductible) pr les groses applis n'importe quel bug est important et doit être résolu d'ou rr
ENREGISTRE EXEC NONDETERMINISTE ET DEBUG DETERMINISTE
on enregistre une execution qui a échoué et on fait du debug sur l'enregistrement en le rejouant aussi souvent qu'on veut car la même éxécution est relancé.
on enregistr l'application du cout c toute l'execution et l'echec qui sont sv sur le disque.  du coup on peut debug la panne
ainsi on debug une trace de façon deterministe pas une execution non deterministe puisque a chaque execution rejouée toutes les ressources et actions sont les mêmes (espace d'adressage, contenu des registres, AS)
RR solve the problem en effectuant ke debug en 2 phases: recording (sv execution de appli) + debug deterministe de la sv en utilisant gdb pour controler le rejeu autant de fois que desiré
capture tous les evenements non deterministes
du coup on meme rejouer les fautes faites par des outils de fuzzing ou d'injection de fautes et les debbuguer

recorder implem
pr scheduler il switch lors d'AS, preemption avec HPC(hardware perf counters) interruption compte nb instruction et arrete apres un certain nb specifié rejeu possible (sv valeur de compteur), signaux aussi rejoué comme préemption de tache

syscall buffer
seccomp-bpf pour tracer les syscalls specifiques
api ctrl ptrace, HPC par ``perf event''
ptrace cher use seccompbpf pour filtrer les AS intercepte via LD\_PRELOAD (sv valeur retour et type AS dans le syscall bufferpour rejeu)

replay implem
emule AS via trace do (small number)
compteur d'instruction interruption apres nb instruction sv durant execution
signaux si handler  restaure registre, handler et frame sv sinon rien
rejoue l'AS mais le retour est celui sv durant l'execution pas le nv
Rr outil de debug utilisant les cmd gdb
%% durant le rejeut il emule les appels systèmes et ``rdtsc'' en écrivant les do nondeterministes sv dans un ``tracee''

advantage:
diminue le cout de debbug et permet de résoudre de nv bug
fonctionne avec bcp d'appli puisque fonctionne firefox
faible sur-cout de temps puisque veut que rr remplace gdb doit pouvoir resoudre pb aussi vite :D overhead depend du type de test faits

neg:
emule une machine mono coeur donc prog parallele ralentis
ne peut pas enregistrer mem dont proc partage => thread pb
tout les AS pas encore implem donc risque de voir apparaître selon appliaction et AS que son processus fait

