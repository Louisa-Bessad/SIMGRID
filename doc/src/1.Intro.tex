\section{Introduction}

%% intro/objectif: virtualisation légère d'applications distribuées (tester des applications distribuées réelles: test regression et performance, légère car on veut tester des centaines d'instances)

%% Applications: stockage distribué (CEPH, TAHOE/LAFS) et RT event processing (Storm)

Dans le cadre de ce stage, nous allons nous intéresser aux applications distribuées. C'est-à-dire les applications dont une partie ou la totalité des ressources  n'est pas stockée sur la machine où l'application s'exécute, mais sur plusieurs machines distinctes. Ces dernières communiquent entre elles via le réseau pour s'échanger les données nécessaires à l'exécution de l'application sur une plate-forme. Les applications distribuées ont de nombreux avantages; elles permettent notamment d'augmenter la disponibilités des données en se les échangeant et en les stockant lors de communication, comme les applications Torrent (BitTorrent, $µ$Torrent...). Grâce au projet BOINC\footnote{https://boinc.berkeley.edu/} par exemple, on peut également partager la puissance de calcul inutilisée de sa machine. Depuis une dizaine d'années la popularité de ces applications distribuées ne cesse de croître. Elles deviennent de plus en plus complexes avec des contraintes et des exigences de plus en plus fortes, en particulier au niveau des performances et de l'hétérogénéité des plate-formes et des ressources utilisées. Il devient donc de plus en plus difficiles de créer de telles applications mais aussi de les tester. En effet, malgré l'évolution des applications distribuées, les protocoles d'évaluation de leurs performances n'ont que peu évolués.

Actuellement, il existe trois façons de tester le comportement d'applications distribuées; l'exécution sur plate-forme réelle, la simulation et l'émulation. 

La première solution consiste à exécuter réellement l'application sur un parc de machines et d'étudier son comportement en temps-réel. Cela permet de tester l'application sur un grand nombre d'environnement. L'outil créé et développé en partie en France pour nous permettre de faire cela est \textbf{Grid'5000}\footnote{Infrastructure de 8000 c\oe urs répartis dans la France entière crée en 2005. \\ https://www.grid5000.fr/mediawiki/index.php/Grid5000:Home}\cite{GRID5000}, un autre outil développé à l'échelle mondiale est \textbf{PlanetLab} \footnote{Crée en 2002, cette infrastructure de test compte aujourd'hui 1340 noeuds. \\ http://www.planet-lab.org}. Néanmoins pour mettre en \oe uvre cette solution complexe, il faut disposer des architectures nécessaires pour effectuer les tests. Il faut également écrire une application capable de gérer toutes ces ressources disponibles. De plus, du fait du partage des différentes plate-formes entre plusieurs utilisateurs, les expériences ne sont pas forcément reproductibles. 

{\color{red}La seconde solution consiste à faire de la simulation, c'est-à-dire à utiliser un programme appelé simulateur pour nous permettre de simuler ce que l'on souhaite étudier.} Dans notre cas, pour pouvoir tester des applications distribuées sur un simulateur, on doit d'abord représenter de façon théorique l'application ainsi que l'environnement d'exécution. Pour cela, on identifie les propriétés de l'application et de son environnement puis on les transforme à l'aide de modèles mathématiques. Ainsi, on va exécuter dans le simulateur le modèle de l'application dans un environnement également modélisé et non l'application réelle. Cette solution est donc facilement reproductible, simple à mettre en \oe uvre du moment que nous savons modéliser notre application et permet de prédire l'évolution du système étudié grâce à l'utilisation de modèles mathématiques. De nos jours, les simulateurs, tel que  \textbf{SIMGRID}\cite{SIMULATION:CASANOVA, SIMULATION:MARTIN}, peuvent simuler des applications distribuées mettant à contribution des milliers de noeuds. Néanmoins, avec la simulation on ne peut valider qu'un modèle et pas l'application elle même puisqu'on exécute le modèle de l'application dans le simulateur. 

La troisième solution consiste à faire de l'émulation, cela signifie que nous allons exécuter réellement l'application mais dans un environnement virtualisé grâce à un logiciel. On fera ainsi croire à l'application qu'elle s'exécute sur une machine autre que l'hôte. Cette solution représente un intermédiaire entre la simulation et l'exécution sur plate-forme réelle. En effet les actions de l'application sont réellement exécutées sur la machine hôte mais on lui fait croire grâce au simulateur qu'elle se trouve dans un environnement différent de la machine hôte. De plus, cette émulation peut-être faite \textit{off-line}; on sauvegarde les actions de l'application sur disque et on les rejoue plus tard dans le simulateur ou \textit{on-line}; les actions sont directement reportées dans le simulateur et on bloque l'application durant le temps nécessaire calculé par le simulateur.

Dans le cadre du projet Simterpose c'est l'émulation qui a été choisie pour tester des applications distribuées. En effet la simulation n'était pas une bonne solution puisque nous voulons valider les applications et non leur modèle. En ce qui concerne l'exécution sur plate-forme réelle il y avait trop de contraintes matérielles à satisfaire. Il existe deux types d'émulation pour les applications distribuées; la virtualisation standard et la ``légère''. On parle de virtualisation ``légère'' quand on souhaite tester des applications sur une centaine d'instances. Dans ce rapport nous allons présenter en section \ref{section:emulation} les méthodes utilisées pour faire de la virtualisation légère: limitation et interception. Puis en section \ref{section:sota} nous verrons les projets qui existent aujourd'hui pour ce type de virtualisation. Pour finir en section \ref{section:simterpose} nous expliquerons pourquoi dans le cadre du projet Simterpose c'est la virtualisation légère par interception qui a été choisie et comment elle fonctionne.


%Intro d'avant
%% Dans le cadre de ce stage nous allons nous intéresser aux applications ditribuées à large échelle et comment on peut les tester et évaluer leurs performances via une combinaison d'émulation et de simulation en utilisant SIMGRID et Simterpose qui sont deux projets européens. SIMGRID a été lancé en 1999 pour étudier des algorithmes d'ordonnancement sur des plateformes hétérogènes dans un environnement distribué et faciliter leur programmation. Il fournit les outils de base nécessaire à la simulation de ce type d'applications. Simterpose s'insère dans le projet SIMGRID afin de pouvoir étudier des applications complètes et pas uniquement leur modèle que l'on fournit habituellement en paramètre au simulateur. Le but est de faire de l'émulation en utilisant un simulateur que sera SIMGRID. Puisque nous nous intéressons aux applications distribuées notre émulateur doit pouvoir\textit{i)} exécuter un grand nombre d'instances d'une même application sur un même système afin de pouvoir debugguer, \textit{ii)} évaluer des applications ayant de nombreuses condition d'exécution (simple n\oe ud, réseau complet), \textit{iii)} collecter les informations concernant l'application pendant qu'elle s'exécute.
