\section{Introduction}

%% intro/objectif: virtualisation légère d'applications distribuées (tester des applications distribuées réelles: test regression et performance, légère car on veut tester des centaines d'instances)

%% Applications: stockage distribué (CEPH, TAHOE/LAFS) et RT event processing (Storm)

Dans le cadre de ce stage nous allons nous intéresser aux applications distribuées, c'est-à-dire les applications dont une partie ou la totalité des ressources  n'est pas stockées sur la machine où l'application s'exécute mais sur plusieurs machines distinctes. Ces dernières communiquent entre elles via le réseau pour s'échanger les données nécessaires à l'exécution de l'appplication sur une plateforme. Les applications distribuées ont de nombreux avantages; elles permettent notamment d'augmenter la disponibilitées des données en se les échangeant et en les stockant lors de communication, c'est le cas des applications de Torrent. Grâce au projet BOINC par exemple, on peut également partager la puissance de calcul inutilisée de sa machine. Depuis une dizaine d'années la popularité de ces applications distribuées ne cesse de croitre\footnote{par exemple l'augmentation du nombre d'utilisateur d'applications distribuées pour le "peer-to-peer"}. Elles deviennent de plus en plus complexes avec des contraintes et des exigences de plus en plus fortes, en particulier au niveau des performances et de l'hétérogénéité des plateformes et des ressources utilisées. Il devient donc de plus en plus difficils de créer de telles applications mais aussi de les tester. En effet, malgré l'évolution des applications distribuées les protocoles d'évaluation de leurs performances n'ont que peu évolués.

Actuellement, il existe trois façons de tester le comportement d'applications distribuées; l'exécution sur plate-forme réelle, la simulation et l'émulation. 

La première solution consiste à exécuter réellement l'application sur un parc de machines et d'étudier le comportement de l'application en temps-réel. Cela permet de tester l'application sur un grand nombre d'environnement. L'outil créé en France pour nous permettre de faire cela est \textbf{Grid'5000} {\color{red}mettre citation et footnote}, un autre outil dévéloppé à l'echelle mondiale est PlanetLab {\color{red}mettre citation et footnote}. Néanmoins pour mettre en \oe uvre cette solution complèxe il faut disposer des architectures nécessaires pour effectuer les tests. Il faut également écrire une application capable de gérer toutes ces ressources disponibles. De plus, du fait du partage des différentes plateformes entre plusieurs utilisateurs les expériences ne sont pas forcément reproductibles. 

La seconde solution consiste à faire de la simulation, c'est-à-dire à utiliser un programme appelé simulateur pour nous permettre de simuler ce que l'on souhaite étudier. Dans notre cas pour pouvoir tester des applications distribuées sur un simulateur, on doit d'abord représenter de façon théorique l'application ainsi que l'environnement d'exécution. Pour cela on identifie les propriétés de l'application et de son environnement et on les réécrit à l'aide de modèles mathématiques. Ainsi on va exécuter dans le simulateur le modèle de l'application dans un environnement également modélisé et non l'application réelle. Cette solution est donc facilement reproductible, simple à mettre en \oe uvre du moment que nous savons modéliser notre application et permet de prédire l'évolution du système étudié grâce à l'utilisation de modèles mathématiques. De nos jours, les simulateurs, tel que  \textbf{SIMGRID}\cite{MARTIN:SimGrid}, peuvent simuler des applications distribuées mettant à contribution des milliers de noeuds. Néanmoins, avec la simulation on ne peut valider qu'un modèle et pas l'application elle même puisqu'on exécute le modèle de l'applciation dans le simulateur. 

La troisième solution consiste à faire de l'émulation, c'est-à-dire que nous allons exécuter réellement l'application mais dans un environnement virtualisé grâce à un logiciel. On fera ainsi croire à l'application qu'elle s'exécute sur une machine autre que l'hôte. Cette solution représente un intermédiaire entre la simulation et l'exécution sur plateforme réelle. En effet les actions de l'applications sont réellement exécutées sur la machine hôte mais on lui fait croire grâce au simulateur qu'elle se trouve dans un environnement différent de la machine hôte. De plus, cette émulation peut-être faite \textit{off-line}; on sauvegarde les actions de l'applications sur disque et on les rejoue plus tard dans le simulateur ou \textit{on-line}; les actions sont directement reportées dans le simulateur et on bloque l'application durant le temps nécessaire calculé par le simulateur.

Dans le cadre du projet Simterpose c'est l'émulation qui a été choisie pour tester des applications distribuées. En effet la simulation n'était pas une bonne solution puisque nous voulons valider les applications et non leur modèle. En ce qui concerne l'exécution sur plate-forme réelle il y avait trop de contraintes matérielles à satisfaire. Il existe deux types d'émulation pour les applications distribuées; la virtualisation standard et la ``légère''. On parle de virtualisation ``légère'' quand on souhaite tester des applications sur une centaine d'instance. Dans ce rapport nous allons présenter en section \ref{section:emulation} ces deux types d'émulation. Puis en section \ref{section:sota} nous verrons les projets qui existent aujourd'hui pour ces deux types de virtualisation. Pour finir en section \ref{section:simterpose} nous expliqueroons pourquoi dans le cadre du projet Simterpose c'est la virtualisation légère qui a été choisi et comment elle fonctionne.


%Intro d'avant
%% Dans le cadre de ce stage nous allons nous intéresser aux applications ditribuées à large échelle et comment on peut les tester et évaluer leurs performances via une combinaison d'émulation et de simulation en utilisant SIMGRID et Simterpose qui sont deux projets européens. SIMGRID a été lancé en 1999 pour étudier des algorithmes d'ordonnancement sur des plateformes hétérogènes dans un environnement distribué et faciliter leur programmation. Il fournit les outils de base nécessaire à la simulation de ce type d'applications. Simterpose s'insère dans le projet SIMGRID afin de pouvoir étudier des applications complètes et pas uniquement leur modèle que l'on fournit habituellement en paramètre au simulateur. Le but est de faire de l'émulation en utilisant un simulateur que sera SIMGRID. Puisque nous nous intéressons aux applications distribuées notre émulateur doit pouvoir\textit{i)} exécuter un grand nombre d'instances d'une même application sur un même système afin de pouvoir debugguer, \textit{ii)} évaluer des applications ayant de nombreuses condition d'exécution (simple n\oe ud, réseau complet), \textit{iii)} collecter les informations concernant l'application pendant qu'elle s'exécute.

%Pq émuler avant
%% Il existe deux façons de faire de l'émulation: la dégradation et l'interception. Dans la première on rajoute la couche d'émulation au-dessus de la plateforme réelle (comme un hyperviseur pour une VM). Mais cela nous empêche d'émuler des machines plus puissantes que l'hôte. En effet, le délai de réponse géré par l'émulateur ne peut-être inférieur à celui de l'hôte sinon l'hôte n'a pas le temps de faire les calculs demandés par l'application. Cette solution choisie notamment par \textbf{Distem}\cite{EMULATION:Distem} est donc limitée à la capacité des plateformes à notre disposition. Dans le cas de l'émultaion par interception, pour faire croire à l'application qu'elle s'exécute sur une machine autre que l'hôte on va utiliser deux outils; un simulateur pour virtualiser l'environnement d'exécution et une API qui va attraper toutes les communications de l'application avec l'hôte et qui les transmettra ensuite au simulateur. Les calculs de l'applications seront effectués sur la machine hôte mais c'est le simulateur qui calculera le temps de réponse à l'application. Pour cela il fera un rapport entre le temps d'exécution du calcul sur la machine hôte (fourni par l'API), la puissance de l'hôte et celle des machines de l'environnement que l'on simule. Le temps de l'application sera donc celui du simulateur et non le temps réel. En effet, l'application quand elle fait un calcul pense être sur une autre machine avec des performances différentes, elle est donc capable de savoir combien de temps prends une certain calcul sur son architecture. Hors sur l'hôte ce calcul ne prendra pas le même temps et l'application se retrouvera avec un temps prévu et un temps qui ne correspondent pas ce qui est problématique. Cette solution d'interception est implémentée dans \textbf{Simterpose}{\color{red}mettre citation}.


 %% Pour ce qui est du type d'émulation utilisé, c'est l'émulation par interception qui a été choisi. Le but final du projet étant de pouvoir évaluer n'importe quelle application distribuée sur n'importe quel type d'architecture, on pourrait se retrouver à devoir émuler des machines plus puissantes que l'hôte, ce que l'émulation par dégradation ne permet pas. Pour faire cette émulation on va utiliser SIMGRID comme simulateur et Simterpose comme API de ce simulateur. Simterpose jouera donc le rôle d'émulateur et nous permettra d'utiliser SIMGRID avec des applications réelles tout en leur faisant croire qu'elles s'exécutent sur des machines distinctes. 
