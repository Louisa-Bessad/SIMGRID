\section{Introduction}

intro/objectif: virtualisation légère d'applications distribuées (tester des applications distribuées réelles: test regression et performance, légère car on veut tester des centaines d'instances)

Applications: stockage distribué (CEPH, TAHOE/LAFS) et RT event processing (Storm)

%Intro d'avant
%% mettre sur 2 pages une présentation de l'entreprise et des activités, et sur 10 à 20 pages la présentation du contexte de la mission, les problématiques, et les solutions envisagés. Plus ce qu'on a déjà fait si on a déjà attaqué le vrai travail.
%% \begin{enumerate}
%% \item entreprise activité (relier au 3 maybe)
%% \item pour les tester 3 méthodes: l'exécution réelle, la simulation de l'exécution en environnement modélise et l'émulation cas où les applications s'exécutent réellement mais sur des environnements virtuels {\color{red} reprendre sujet stage à développer dans 1} 
%% \item Dans le cadre de ce stage nous allons nous intéresser aux applications ditribués à large échelle et comment on peut les tester et évaluer leurs perfs via une combinaison d'émulation et de simulation en utilisant SIMGRID et Simterpose qui sont deux projets européens. SIMGRID a été lancé en 1999 pour étudier des algorithmes d'ordonnancement sur des plateformes hétérogènes dans un environnement distribué et faciliter leur programmation. Il fournit les outils de base nécessaire à la simulation de ce type d'applications. Simterpose s'insère dans le projet SIMGRID afin de pouvoir étudier des applications complètes et pas uniquement leur modèle que l'on fournit habituellement en paramètre au simulateur. Le but est de faire de l'émulation en utilisant un simulateur que sera SIMGRID. Puisque nous nous intéressons aux applications distribuées notre émulateur doit pouvoir\textit{i)} exécuter un grand nombre d'instances d'une même application sur un même système afin de pouvoir debugguer, \textit{ii)} évaluer des applications ayant de nombreuses condition d'exécution (simple n\oe ud, réseau complet), \textit{iii)} collecter les informations concernant l'application pendant qu'elle s'exécute.
%% \item SIMGRID et Simteprose = projet europeen blablabla
%% \item nous ce sera la partie émulation sur laquelle nous travaillerons
%% \item plan maybe 2.pourquoi faire de l'émulation simulation et pas les deux autres 3. comment ça marche réellement 4.ce qu'il y a à faire et pour quand
%% \item on veut tester les api sans avoir accès aux codes sources.
%% \end{enumerate}

%Pq émuler avant
%% Actuellement, il existe trois façons de tester le comportement d'applications distribuées; l'exécution sur plate-forme réelle, la simulation et l'émulation. 

%% La première solution consiste à exécuter réellement l'application sur un parc de machines et d'étudier le comportement de l'application en temps-réel. Cela permet de tester l'application sur un grand nombre d'environnement. L'outil créé en France pour nous permettre de faire cela est \textbf{Grid'5000} {\color{red}mettre citation et footnote}, un autre outil dévéloppé à l'echelle mondiale est PlanetLab {\color{red}mettre citation et footnote}. Néanmoins pour mettre en \oe uvre cette solution complèxe il faut disposer des architectures nécessaires pour effectuer les tests. Il faut également écrire une application capable de gérer toutes ces ressources disponibles. De plus, du fait du partage des différentes plateformes entre plusieurs utilisateurs les expériences ne sont pas forcément reproductibles. 

%% La seconde solution consiste à faire de la simulation. C'est-à-dire qu'on va exécuter un programme appelé simulateur pour nous permettre de simuler ce que l'on souhaite étudier. Dans notre cas on veut tester des applications sur des environnements distribués. Pour pouvoir tester des applications sur un simulateur, on doit d'abord représenter de façon théorique l'application ainsi que l'environnement d'exécution. Pour cela on identifie les propriétés de l'application et de son environnement et on les réécrit à l'aide de modèles mathématiques. Ainsi on va exécuter dans le simulateur le modèle de l'application dans un environnement également modélisé et non l'application réelle. Cette solution est donc facilement reproductible, simple à mettre en \oe uvre du moment que nous savons modéliser notre application et permet de prédire l'évolution du système étudié grâce à l'utilisation de modèles mathématiques. De nos jours, les simulateurs, tel que  \textbf{SIMGRID}\cite{MARTIN:SimGrid}, peuvent simuler des applications distribuées mettant à contribution des milliers de noeuds. Néanmoins, avec la simulation on ne peut valider qu'un modèle et pas l'application elle même puisqu'on exécute le modèle de l'applciation dans le simulateur. 

%% La troisième solution consiste à faire de l'émulation, c'est-à-dire que nous allons exécuter réellement l'application mais dans un environnement virtualisé grâce à un logiciel. On fera ainsi croire à l'application qu'elle s'exécute sur une machine autre que l'hôte. Cette soution représente un Il existe deux façons de faire de l'émulation: la dégradation et l'interception. Dans la première on rajoute la couche d'émulation au-dessus de la plateforme réelle (comme un hyperviseur pour une VM). Mais cela nous empêche d'émuler des machines plus puissantes que l'hôte. En effet, le délai de réponse géré par l'émulateur ne peut-être inférieur à celui de l'hôte sinon l'hôte n'a pas le temps de faire les calculs demandés par l'application. Cette solution choisie notamment par \textbf{Distem}\cite{EMULATION:Distem} est donc limitée à la capacité des plateformes à notre disposition. Dans le cas de l'émultaion par interception, pour faire croire à l'application qu'elle s'exécute sur une machine autre que l'hôte on va utiliser deux outils; un simulateur pour virtualiser l'environnement d'exécution et une API qui va attraper toutes les communications de l'application avec l'hôte et qui les transmettra ensuite au simulateur. Les calculs de l'applications seront effectués sur la machine hôte mais c'est le simulateur qui calculera le temps de réponse à l'application. Pour cela il fera un rapport entre le temps d'exécution du calcul sur la machine hôte (fourni par l'API), la puissance de l'hôte et celle des machines de l'environnement que l'on simule. Le temps de l'application sera donc celui du simulateur et non le temps réel. En effet, l'application quand elle fait un calcul pense être sur une autre machine avec des performances différentes, elle est donc capable de savoir combien de temps prends une certain calcul sur son architecture. Hors sur l'hôte ce calcul ne prendra pas le même temps et l'application se retrouvera avec un temps prévu et un temps qui ne correspondent pas ce qui est problématique. Cette solution d'interception est implémentée dans \textbf{Simterpose}{\color{red}mettre citation}.

%%  Cette émulation peut-être faite off-line; on sauvegarde les actions de l'applications sur disque et on les rejoue plus tard dans le simulateur ou on-line; les actions sont directement reportées dans le simulateur et on bloque l'application durant le temps nécessaire calculé par le simulateur.

%% Dans le cadre de ce projet c'est l'émulation qui a été choisie. En effet la simulation n'était pas une bonne solution puisque nous voulons valider les applications et non leur modèle. En ce qui concerne l'exécution sur plate-forme réelle il y avait trop de contraintes matérielles à satisfaire. Pour ce qui est du type d'émulation utilisé, c'est l'émulation par interception qui a été choisi. Le but final du projet étant de pouvoir évaluer n'importe quelle application distribuée sur n'importe quel type d'architecture, on pourrait se retrouver à devoir émuler des machines plus puissantes que l'hôte, ce que l'émulation par dégradation ne permet pas. Pour faire cette émulation on va utiliser SIMGRID comme simulateur et Simterpose comme API de ce simulateur. Simterpose jouera donc le rôle d'émulateur et nous permettra d'utiliser SIMGRID avec des applications réelles tout en leur faisant croire qu'elles s'exécutent sur des machines distinctes. 

%% Maintenant que nous savons comment nous allons tester les applications distribuées nous allons voir comment le fonctionnement de Simterpose va nous permettre de faire de l'émulation par interception.
