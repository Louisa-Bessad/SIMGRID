\section{Introduction}

%% intro/objectif: virtualisation légère d'applications distribuées (tester des applications distribuées réelles: test regression et performance, légère car on veut tester des centaines d'instances)

%% Applications: stockage distribué (CEPH, TAHOE/LAFS) et RT event processing (Storm)

Dans le cadre de ce stage, nous allons nous intéresser aux applications distribuées. \textit{ Autrement dit aux} applications dont une partie ou la totalité des ressources  n'est pas stockée sur la machine où l'application s'exécute, mais sur plusieurs machines distinctes. Ces dernières communiquent entre elles via le réseau pour s'échanger les données nécessaires à l'exécution de l'application. Les applications distribuées ont de nombreux avantages; elles permettent notamment d'augmenter la disponibilités des données en se les échangeant,\textit{ comme les applications Torrent (BitTorrent, $µ$Torrent...)}. Grâce au projet BOINC\footnote{\url{https://boinc.berkeley.edu/}} par exemple, on peut partager la puissance de calcul inutilisée de sa machine. Depuis une dizaine d'années la popularité de ces applications distribuées ne cesse de croître. Elles deviennent de plus en plus complexes avec des contraintes et des exigences de plus en plus fortes, en particulier au niveau des performances et de l'hétérogénéité des plate-formes et des ressources utilisées. Il devient donc de plus en plus difficiles de créer de telles applications mais aussi de les tester. En effet, malgré l'évolution des applications distribuées, les protocoles d'évaluation de leurs performances n'ont que peu évolués.

Actuellement, il existe trois façons de tester le comportement d'applications distribuées; l'exécution sur plate-forme réelle, la simulation et l'émulation. 

La première solution consiste à exécuter réellement l'application sur un parc de machines et d'étudier son comportement en temps-réel. Cela permet de la tester sur un grand nombre d'environnement. L'outil créé et développé en partie en France pour nous permettre de faire cela est \textbf{Grid'5000}\footnote{Infrastructure de 8000 c\oe urs répartis dans la France entière crée en 2005. \\ \url{https://www.grid5000.fr/mediawiki/index.php/Grid5000:Home}}\citet{GRID5000}, un autre outil développé à l'échelle mondiale est \textbf{PlanetLab} \footnote{Crée en 2002, cette infrastructure de test compte aujourd'hui 1340 noeuds. \\ \url{http://www.planet-lab.org}}. Néanmoins pour mettre en \oe uvre ces solutions complexes, il faut disposer des infrastructures nécessaires pour effectuer les tests. Il faut également écrire une application capable de gérer toutes ces ressources disponibles. De plus, du fait du partage des différentes plate-formes entre plusieurs utilisateurs, les expériences ne sont pas forcément reproductibles. 

{\color{red}\textit{La seconde solution consiste à faire de la simulation, c'est-à-dire à utiliser un programme appelé simulateur pour nous permettre de simuler ce que l'on souhaite étudier.}} Dans notre cas, pour pouvoir tester des applications distribuées sur un simulateur, on doit d'abord représenter de façon théorique l'application ainsi que l'environnement d'exécution. Pour cela, on identifie les propriétés de l'application et de son environnement puis on les transforme à l'aide de modèles mathématiques. Ainsi, on va exécuter dans le simulateur le modèle de l'application dans un environnement également modélisé et non l'application réelle. Cette solution est donc facilement reproductible, simple à mettre en \oe uvre, \textit{ quand on sait} modéliser l'application, et permet de prédire l'évolution du système étudié grâce à l'utilisation de modèles mathématiques. De nos jours, les simulateurs, tel que  \textbf{SIMGRID}\citet{SIMULATIONCASANOVA, SIMULATIONMARTIN}, peuvent simuler des applications distribuées mettant à contribution des milliers de noeuds. Néanmoins, avec la simulation on ne peut valider qu'un modèle et pas l'application elle même puisqu'on exécute seulement un modèle. 

La troisième solution consiste à faire de l'émulation, cela signifie que nous allons exécuter réellement l'application mais dans un environnement virtualisé grâce à un logiciel, l'émulateur. Ce dernier joue le rôle d'intercepteur et utilise un simulateur pour virtualiser l'environnement d'exécution.
%On fera ainsi croire à l'application qu'elle s'exécute sur une machine autre que l'hôte.
Cette solution représente un intermédiaire entre la simulation et l'exécution sur plate-forme réelle visant à résoudre les limitations de ces deux solutions. En effet, les actions de l'application sont réellement exécutées sur la machine hôte, autrement dit la machine réelle sur laquelle s'exécute l'émulation. Mais on fait croire à l'application grâce au simulateur qu'elle se trouve dans un environnement différent de la machine \textit{réelle}. De plus, cela évite d'avoir deux versions de l'application en terme de code: une pour la simulation et une pour la production. Dans notre cas l'émulation peut-être faite \textit{off-line}; on sauvegarde les actions de l'application sur disque et on les rejoue plus tard dans le simulateur ou \textit{on-line}; \textit{ on bloque l'application le temps que les actions soient reportées dans le simulateur pour qu'il calcule le temps de réponse de la plate-forme simulée}.

Dans le cadre du projet Simterpose c'est l'émulation qui a été choisie pour tester des applications distribuées. En effet la simulation n'était pas une bonne solution puisque nous voulons valider les applications et non leur modèle. En ce qui concerne l'exécution sur plate-forme réelle, il y avait trop de contraintes matérielles à satisfaire.

{\color{red}TODO: Transition}
Il existe deux types d'émulation pour les applications distribuées; la virtualisation standard et la ``légère''. On parle de virtualisation ``légère'' quand on souhaite tester des applications sur une centaine d'instances. Dans ce rapport nous allons présenter en section \ref{section:emulation} les méthodes utilisées pour faire de la virtualisation légère: limitation et interception. Puis en section \ref{section:sota} nous verrons les projets qui existent aujourd'hui pour ce type de virtualisation. Pour finir en section \ref{section:simterpose} nous expliquerons pourquoi dans le cadre du projet Simterpose c'est la virtualisation légère par interception qui a été choisie et comment elle fonctionne.
