\subsection{Améliorations apportées à Simterpose}

Lorsqu'on j'ai commencé mon stage, Simterpose était spécifique aux architectures 64bits. En effet, lorsqu'on intercepte les appels systèmes il faut pouvoir récupérer les valeurs contenues dans les registre en entrée puis pouvoir écrire dans ces mêmes registres à la sortie de l'appel. Or, Simterpose ne gérait pas le remplissage des registres et l'utilisation de ces derniers lorsqu'on utilise une architecture 32bits. J'ai donc cherché les différences au niveau des registres liées afin de pouvoir permettre à Simterpose de s'exécuter sur des architectures 32bits. Tout d'abord les registres ne portent pas les mêmes noms en 64bits et 32bits, cf tableau \ref{register}. Il faut donc utiliser des noms différents selon l'architecture si on veut récuperer des valeurs. De plus, certaines macro et appels systèmes n'existent pas sur des architectures 64bits et inversement. C'est la cas par exemple de \texttt{send} et \texttt{recv}, or ces appels systèmes sont très importants pour nous car ils touchent le réseau. Ces deux appels ne sont définis que pour des architectures 32bits , sur des architectures 64bits quand on les utilise ils sont remplacés par les appels sytèmes \texttt{sendto} et \texttt{recvfrom}.

Ensuite, Une mise à niveau de Simterpose a été effectué afin qu'il puisse utiliser les dernières version de SimGrid. Au début de mon stage, Simterpose utilisait une version de SimGrid datant de 2011, maintenant il utilise la version  {\color{red}XXX} sorti en {\color{red}XXX} 2015.

De plus, nous souhaitions pouvoir utiliser un autre {\color{red}débogueur} en plus \texttt{gdb}. Nous avons choisi Valgrind de par les nombreux modules qu'il fourni, notamment \texttt{memcheck} qui traque les fuites mémoires et résume tout ce qui a été réservé, libérée et perdu en mémoire à la fin de l'exécution. Pour permettre son utilisation avec Simterpose nous avons dû implémenter l'appel système mémoire \texttt{fcntl}, sinon il ne pouvait accéder à l'exécution de Simterpose pour pouvoir la controler. Cela n'était pas prévu à la création de Simterpose puisque nous souhaitions juste intercepter les appels systèmes réseaux, temporels et gérer les processus pour maintenir notre virtualisation et aucun  {\color{red}débogueur} autre que \texttt{gdb} ne souhaitait être utilisé à ce moment-là.

Pour finir, le but de Simterpose est d'exécuter des applications distribuées large échelle, notamment des applciations de Torrent. Ainsi, lorsqu'on exécute des applications de ce type il faut bien gérer le système de fichier qu'utilise Simterpose et le maintenir à jour. Pour chaque socket ou fichier Simterpose dispose d'un descripteur avec des compteurs de références, les processus qui les référencent, les verrous qui peuvent être posé... De fait, pour maintenir notre système de fichier à jour on va intercepter chaque appel système touchant aux fichiers et faire les modifications sur notre système de fichier ``virtuel'' en utilisant \texttt{ptrace}, puis on laisse l'appel système s'exécuter. Actuellement on sait gérer les appels systèmes: \texttt{open},  \texttt{close}, \texttt{creat}, \texttt{dup}, \texttt{dup2}, \texttt{poll}, \texttt{fcntl}, \texttt{lseek}, \texttt{read}, \texttt{write}.
