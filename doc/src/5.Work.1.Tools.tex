\subsection{Améliorations apportées à Simterpose}

Lorsqu'on intercepte les appels systèmes il faut pouvoir récupérer les valeurs contenues dans les registre en entrée puis pouvoir écrire dans ces mêmes registres à la sortie de l'appel. Or, au début de mon stage, Simterpose était spécifique aux architectures 64bits. Il ne gérait pas le remplissage des registres et l'utilisation de ces derniers lorsqu'on utilisait une architecture 32bits. Nous avons donc cherché les différences entre ces deux architectures afin de pouvoir exécuter Simterpose sur des plateformes 32bits. La première différence entre ces deux architectures est que les registres ne portent pas les mêmes noms en 64bits et 32bits, cf tableau \ref{register}. Il faut donc utiliser des noms différents selon l'architecture si on veut récuperer des valeurs. Deuxièmement, certaines \texttt{macro} et appels systèmes n'existent pas sur des architectures 64bits et inversement. C'est la cas de deux appels systèmes particulièrement importants car ils touchent au réseau: \texttt{send} et \texttt{recv}. Ces deux appels ne sont définis que pour des architectures 32bits, sur des architectures 64bits quand on les utilise ils sont remplacés par les appels sytèmes \texttt{sendto} et \texttt{recvfrom}.

Ensuite, une mise à niveau de Simterpose a été effectuée afin qu'il puisse utiliser les dernières version de SimGrid. Pour cela il a fallu remplacer de vieilles fonctions encore utilisées dans le code de Simterpose par les nouvelles utilisées dans SimGrid. Cela a également permi de mettre à jour un problème dans SimGrid dû à l'accès d'un pointeur dont on ne vérifiait pas qu'il n'était pas nul. Au début de mon stage, Simterpose utilisait une version de SimGrid datant de 2011, maintenant il utilise la version  {\color{red}XXX} sorti en {\color{red}XXX} 2015.

De plus, nous souhaitions pouvoir utiliser un autre {\color{red}débogueur} en plus de \texttt{gdb}. Nous avons choisi Valgrind pour les nombreux modules qu'il fourni. Notamment \texttt{memcheck} qui est pour nous le plus intéressant. Ce dernier traque les fuites mémoires et résume en fin d'exécution tout ce qui a été réservé, libérée et perdu en mémoire. Pour permettre son utilisation avec Simterpose nous avons dû implémenter l'appel système \texttt{fcntl}. Valgrind utilise cet appel système pour accéder à l'exécution de Simterpose et peut ainsi la controler pour chercher les fuites mémoires. Cela n'était pas prévu à la création de Simterpose puisque nous souhaitons juste intercepter les appels systèmes réseaux, temporels et gérer les processus et leurs threads pour maintenir notre environnement virtuel et aucun  {\color{red}débogueur} autre que \texttt{gdb} ne souhaitait être utilisé à ce moment-là.

Pour finir, le but de Simterpose est d'exécuter des applications distribuées large échelle, notamment des applciations de Torrent. De fait, lorsqu'on exécute des applications de ce type, le système de fichier de la machine hôte est en permanence utilisé. Simterpose dispose en parallèle de son propre système de fihier. Pour chaque socket ou fichier il dispose d'un descripteur avec des compteurs de références, les processus qui les référencent, les verrous qui peuvent être posés... Nous devons donc nous aussi maintenir à jour notre système de fichier dans le cas où nous lancerions ce genre d'applications. Ainsi, nous devons maintenant intercepter les appels systèmes touchant aux fichier en plus de ceux affectant le réseau en utilisant toujours \texttt{ptrace}. Lorsqu'on les intercepte il faut récupérer les modifications qui seront effectués sur le système de fichier réel une fois qu'on aura laisser passer l'appel système et les appliquer au système de fichier propre à Simterpose. Actuellement Simterpose gére les appels systèmes: \texttt{open},  \texttt{close}, \texttt{creat}, \texttt{dup}, \texttt{dup2}, \texttt{poll}, \texttt{fcntl}, \texttt{lseek}, \texttt{read}, \texttt{write}.
