\subsection{Réseau de communications}
\label{subsection:network_implementaion}

Afin d'implémenter le réseau de communications, tel qu'il est présenté en section \ref{subsubsection:fonctionnement_reseau}, nous avons écrit pour chaque appel affectant le réseau une version de l'appel utilisant l'\textit{address translation} et une utilisant la \textit{full mediation}. Une des deux versions sera exécutée par \texttt{ptrace} à chaque interception de l'appel selon le type de médiation utilisée.

Dans le cas de l'\textit{address translation}, nous allons récupérer via \texttt{ptrace} les valeurs contenues dans les registres. Ensuite, selon le type d'appel système réseau dont il s'agit, on effectue des actions différentes. Pour les appels qui concernent la création de sockets ainsi que l'ouverture et la fermeture de connexion (\texttt{socket}, \texttt{bind}, \texttt{connect}, \texttt{listen}, \texttt{accept}, \texttt{shutdown}, \texttt{close}) on crée dans la table de correspondance <IP, port>$_{virtuel}$ / <IP, port>$_{\text{réel}}$ un nouvelle entrée, si elle n'existe pas déjà. Cela nous permettra de maintenir la virtualisation en traduisant les couples <IP, port>$_{virtuel}$ en <IP, port>$_{\text{réel}}$ lors d'appels systèmes effectuant des communications sur le réseau. Pour les appels concernant les échanges de messages, on récupère en utilisant les tables de traductions le couple  $<IP, port>_{\text{réel}}$ correspondant aux informations passée en paramètre. Pour finir, quelque soit l'appel système, on va écrire dans ses registres les valeurs traduites grâce à \texttt{ptrace}. Puis, on laisse l'appel système s'exécuter. À la sortie, on refait la même chose à la seule différence qu'on traduit le couple  <IP, port>$_{reel}$ en <IP, port>$_{virtuel}$.

Pour la version de l'appel système qui utilise la \textit{full mediation}, on récupère comme précédement les paramètres de l'appel système contenus dans les registres. Dans cette médiation il est nécessaire d'empêcher les appels systèmes de s'exécuter. On neutralise donc l'appel système via \texttt{ptrace} pour empêcher son exécution quand on rendra la main à l'application. Puis, en fonction du type d'appel système réseau on effectue différentes actions. Aucune action n'est nécessaire pour les appels qui concernent la gestion du réseau (création de socket, ouverture et fermeture de connexion...) puisque dans ce type de médiation aucune socket n'est créée et connectée. Pour les appels systèmes qui vont effectuer des échanges de messages, on crée une tâche SimGrid qui va permettre d'écrire ou de lire les données à envoyer ou recevoir. Puis, pour tous les types d'appels systèmes réseau, on écrit dans les registres de l'appel avec \texttt{ptrace}: la valeur de retour de l'appel et éventuellement d'autres informations dans différents registres selon l'appel. C'est le cas par exemple, quand on reçoit des données: elles sont lues durant l'exécution de l'appel système par le noyau. Elles sont ensuite écrites dans le buffer d'écriture dont l'adresse est passée en paramètre.
