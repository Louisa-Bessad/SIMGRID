\section{Pourquoi choisir l'émulation simulée}

Il existe trois façons de tester des applications distribuées. La première consiste à exécuter réellement l'application sur un parc de machines et d'étudier le comportement de l'application en temps-réel, ce que fait actuellement \textbf{Grid'5000} {\color{red}mettre citation}. Néanmoins pour mettre en \oe uvre cette solution complexe il faut disposer des architectures nécessaires pour effectuer les tests. De part le partage des différentes plateformes entre divers utilisateurs les expériences ne sont pas forcément reproductibles. Une deuxième solution consiste à simuler l'exécution des applications à l'aide d'un simulateur tel que \textbf{SIMGRID} {\color{red}mettre citation}. On doit alors modéliser l'application ainsi que l'environnements d'exécution grâce à des modèles mathématiques. Le problème avec la simulation est que l'on exécute pas vraiment l'application, on ne peut alors valider qu'un modèle et pas l'application puisqu'on réécrit l'application selon le modèle. Un des buts du projet étant de tester les applicationis sans avoir accès à leur code source, on ne peut donc pas choisir cette solution ou pas toute seule en tout cas. La troisième solution consiste à faire de l'émulation, c'est-à-dire que nous allons exécuter réellement l'applications mais dans en environnement virtuels. Ainsi nous aurons un simulateurs qui gérera l'environnement, l'application qui s'exécutera réellement sur la machine hôte et une API qui fera le lien entre l'application qui s'exécute et l'environnement simulé. On fera ainsi croire à l'application qu'elle s'exécute sur une machine autre que l'hôte. Il existe deux façons de faire de l'émulation: la dégradation et l'interception. Dans la première on rajoute la couche d'émulation au-dessus de la plateforme réelle (comme un hyperviseur pour une VM). Mais cela nous empêche d'émuler des machines plus puissante que l'hôte car le délai de réponse géré par l'émulateur ne peut-être inférieur à celui de l'hôte sinon l'hôte n'a pas le temps de faire les calculs nécessaires à l'application. Cette solution choisie par \textbf{Distem}{\color{red}mettre citation} est donc limitée à la capacité des plateformes à notre disposition. Dans le cas de l'interception pour faire croire à l'application qu'elle s'exécute sur une machine autre que l'hôte on va attraper toutes ses communications via une API du simulateur qui ensuite les transmetra au simulateur. Ce dernier s'occupera de calculer le temps de réponses de ces commumnications en se basant sur les performances de la machine qu'on est en train de simuler. Les calculs seront effectués sur la machine hôte mais le temps de réponse à l'application sera géré par le simulateur en fonction de l'architecture que l'on simule en utilisant le temps d'exécution de la machine hôte injectés dans le simulateur et en comparant les performances des deux architectures. Ainsi le temps de l'application sera celui du simulateur et non le temps réel. Cette solution est implémentée dans \textbf{Simterpose}{\color{red}mettre citation}. Dans notre cas d'émulation simulation, nous allons utiliser SIMGRID comme simulateur et Simterpose comme API de ce simulateur. Nous aurons donc Simterpose qui permettra d'utiliser SIMGRID avec des applications réelles en leur faisant croire qu'elles s'exécutent sur des machines distribuées. Maintenant que nous savons comment nous allons tester les applications distribuées nous allons voir comment fonctionne notre ``émulateur'' Simterpose.
