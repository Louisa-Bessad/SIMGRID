#+STARTUP: showall

* Findings
Yeah you find my beautiful reporting file
** Introduction 

** Related Work

** Bibliography
*** Articles
Luc Sarzyniec, Tomasz Buchert, Emmanuel Jeanvoine, Lucas Nussbaum. Design and
Eval- uation of a Virtual Experimental Environment for Distributed
Systems. [Research Report] RR-8046, 2012. <hal-00724308v1> Martin
Quinson. SimGrid: a Generic Framework for Large-Scale Distributed Experiments.
9th International conference on Peer-to-peer computing - IEEE P2P 2009, Sep
2009, Seattle, United States. IEEE. <inria-00435802> KENISTON, Jim,
MAVINAKAYANAHALLI, Ananth, PANCHAMUKHI, Prasanna, et al. Ptrace, utrace,
uprobes: Lightweight, dynamic tracing of user apps. In : Proceedings of the 2007
Linux Symposium. 2007. p. 215-224.
*** Reports of internships
http://www.loria.fr/~quinson/Research/Students/2014-master-simterpose-slides.pdf
http://www.loria.fr/~quinson/Research/Students/2014-master-simterpose-rapport.pdf
http://www.loria.fr/~quinson/Research/Students/2013-master-simpad-rapport.pdf
http://www.loria.fr/~quinson/Research/Students/2012-master-simterpose-rapport.pdf
http://www.loria.fr/~quinson/Research/Students/2010_guthmuller-rapport.pdf
http://www.loria.fr/~quinson/Research/Students/2010_guthmuller-slides.pdf
** Contribution 


* Development
** Data Provenance

* Journal
** 1rst week March
*** Things done
- Lire les papiers de Chloé, Guillaume, Marion et les papiers cités par Chloé.
*** Blocking points and questions
- Je n'arrive pas à comprendre qui s'éxecute, où et comment. Les applis tournent
 sur la machine hote, seul les actions qui ont besoin d'interragir avec
 l'environnement (réseau car appl distribuées) sont envoyées dans le simulateur?
- Si on exécute les appli sur la machine hote, dans ce cas en quoi ça permet
d'exécuter sur différentes machine avec des puissances de calcul différentes?
--> Benchmark et rejeu pour ce qui est calcul d'application et envoie ce temps
dans le simulateur qui ajuste en fonction de la plate-forme qu'il simule. Ce qui
fait une émulation simulation.  --> 4 choses: COMM (temps de communication), SEB
(temps calcul), obtenir le temps,DNS (resolution de nom) Obtenir l'heure pas de
transformation en AS (perte de perfo avec switch contexte), LD_PRELOAD (combien
de temps depuis le dernier chronostrart/stop) cat /proc/self/maps pour voir les
différents segments mémoire de processus (vsyscall: memoire kernel mappe pour
avoir l'heure, emplacement des lib...)
*** Planned work 
*** DONE Lire code et le comprendre (relire le ld_preload_pthread)
*** TODO Faire tourner le programme actuel
*** TODO Les papiers dans /biblio/to_read

** 09.03.2015
*** Things done
- Lire les poc et les comprendre
- Lire les codes de tests/apps (bon brain storming about socket functions)
- Fic server_poll et server_poll_multi fastidieux.
*** Blocking points and question
- un appel dans le fichier ldpreload_pthread/mdfpthread.c
- quand on fait un fork le parent ne s'attache pas au fils??? Il y a juste le
 fils qui fait un PTRACE_ME???  (revoir l'annexe de Guillaume)
- c'est quoi "tesh"?  --> tesh, c'est le testing shell, l'outil qu'on a écrit
dans simgrid pour nos tests d'intégration. Je l'avais posé en sujet scolaire une
fois. http://webloria.loria.fr/~quinson/Teaching/RS/projet-test.pdf La version
dans simgrid est en perl de nos jours, mais y'a une version en C assez balèze
qui demeure. Le principal défaut de la version C est de ne pas être porté à
windows (forcément).
*** Planned work
- Laissé de côté le fichier apps/chess_adavanced.c
- Relire send_client/server serverMultiClients.c
- Mettre au propre note et schéma
*** TODO Lire le code dans src

** 10-13.03.2015
*** Things done
- essayer de trouver par quel bout commencer à lire les fichiers contenu dans
src --> .h lus
- commencer à faire des liens entre les différents fichiers et structures
*** Blocking point
*** Planned work
- lire les .c notamment sys_* et syscall_process
*** TODO Mettre les en-têtes de fichiers et commentaire en en, corriger le code si besoin
- peupler les sys_* avec ctrl-X ctrl-V (suivre strace)
- remplacer le switch du syscall_process par un tableau de pointeurs de
  fonctions
- améliorer la testsuite avec un script diff entre les sorties simterpose et
  strace --> algorithme de diff wikipédia --> longuest common subsequence

** 16.03.2015
*** Things done
- lire sys_*
*** Blocking points
- où sont définies les macro MSG_* et les xbt_dynar_* --> /opt/simgrid/include
- à quoi sert le while de process_runner (simterpose.c) --> processus lancé via
le ptrace on le bloque dès que quelque chose avec le resume (pendant le resume
fait ses calculs) si on en sort = AS à gérer
- à quoi servent les processus clonés et la fonction main_loop (simterpose.c)?
--> main_loop = process_runner quand on est dans un clone --> quand fork ou
create on fait un clone en fait du coup c'est l'AS clone qui gère ça.
*** Planned work
- lire le fichier syscall_process.c et autres tools en .c

** 17-18-19.03.2015
*** Things done
-lire syscall_process.c
*** Blocking points
- qu'est ce qu'une MSG task et à quoi ça sert --> voir 101 de SIMGRID
- pourquoi à l'entrée du syscall_write on ne fait rien si on est en
address_translation --> toute la petite sauce a été faite dans le open déjà
- pourquoi incrémenter le compteur de référence à la sortie du syscall_write,
  entree du syscall_write alors qu'il est déjà incrémenté dans le open et qu'on
  le décrémente ensuite??? -- Est-ce pour éviter de fermer un fd à 0 si on
  l'utilise ailleurs...
- traitement des pipe dans syscall_write et process_close_call = ????
- pourquoi le syscall_poll_pre ne fonctionne pas?
- pourquoi on n'a pas de return à la sortie de chaque syscall dans le
  process_handle?
- que fait sys_build_select et pourquoi le syscall_select_pre renvoie une valeur
 de match alors que c'est l'AS noyau qui devrait renvoyer ça?

*** Planned work
- lire le code de strace
- read SIMGRID101
*** TODO réorganiser le switch de process_handle pour ne pas avoir chercher de bon ordre de lecture...
- faire un syscall_select_post comme syscall_poll_post



* Conclusion
Hello Next Guy! At the end remote all the jokes :p
